#!/usr/bin/env ruby

require 'optparse'
require File.dirname(__FILE__) + '/../lib/judo'
require File.dirname(__FILE__) + '/../lib/judo/commandline_helpers'

include JudoCommandLineHelpers

options = Judo::Base.defaults

action = ARGV.shift

ARGV.unshift "-h" unless action

optparse = OptionParser.new do|opts|
  opts.banner = <<banner
Usage: judo launch [options] SERVER ...
       judo create [options] SERVER ...
       judo destroy [options] SERVER ...

       # SERVER can be formatted as NAME or NAME:GROUP or +N or +N:GROUP
       # where N is the number of servers to create or launch
       # 'launch' only differs from 'create' in that it immediately starts the server

       judo start [options] [SERVER ...]
       judo stop [options] [SERVER ...]
       judo restart [options] [SERVER ...]

       judo commit [options] GROUP

       judo snapshot [options] SERVER SNAPSHOT ## take an ebs snapshot of a server
       judo snapshots [options] [SERVER ...]   ## show current snapshots on servers
       judo animate [options] SNAPSHOT SERVER    ## create a new server from a snapshot
       judo erase [options] SNAPSHOT           ## erase an old snapshot

       judo swap [options] SERVER SERVER     ## swap elastic IP's and names on the two servers

       judo watch [options] SERVER         ## watch the server's boot process
       judo info [options] [SERVER ...]
       judo console [options] [SERVER ...] ## shows AWS console output
       judo ssh [options] [SERVER ...]     ## ssh's into the server

       # SERVER can be formatted as NAME or NAME:GROUP
       # or :GROUP to indicate the whole group.
       # If no servers are listed all servers are assumed.

       judo list [options]    ## lists all servers
       judo groups [options]  ## lists all groups

       judo volumes [options] ## shows all EBS volumes and what they are attached to
       judo ips [options]     ## shows all elastic ips and what they are attached to

banner

  # start stop create destroy launch restart info console
  # list volumes ips

  opts.on( '-c', '--config DIR', 'Specify the location of the config dir' ) do |dir|
    options[:judo_dir] = dir
  end
  opts.on( '-f', '--force', 'Force a stop or restart (immediately force detach volumes)' ) do
    options[:force] = true
  end
  opts.on( '-d', '--domain DOMAIN', 'Specify a judo domain within an AWS account' ) do |domain|
    options[:domain] = domain
  end
  opts.on( '-r', '--repo DIR', 'Specify the location of the repo dir' ) do |dir|
    options[:repo] = dir
  end
  opts.on( '-D', '--data DATA', 'Specify an instance specific string to be used during boot on create or launch' ) do |data|
    options[:data] = data
  end
  opts.on( '-t', '--type TYPE', 'Specify an instance type different from the config on server start' ) do |type|
    options[:instance_type] = type
  end
  opts.on( '-B', '--boot BOOT', 'Instance specific string (like --data) but for this boot only' ) do |data|
    options[:boot] = data
  end
  opts.on( '-i', '--ip IP', 'Specify an exsiting elastic_ip address on server creation' ) do |ip|
    options[:elastic_ip] = ip
  end
  opts.on( '-a', '--accessid ID', 'Specify the AWS access ID' ) do |id|
    options[:access_id] = id
  end
  opts.on( '-k', '--keypair KEY', 'Speicy the AWS keypair pem file to use or \'create\'' ) do |key|
    if key == 'create'
      options[:key_create] = true
    elsif File.basename(key) =~ /(.*)[.]pem$/
      options[:key_name] = $1
      options[:key_material] = File.new(key).read
    else
      abort "Key file must be KEY_NAME.pem"
    end
  end
  opts.on( '-s', '--secret KEY', 'Specify the AWS access secret key' ) do |key|
    options[:access_secret] = key
  end
  opts.on( '-g', '--group GROUP', 'Specify the default group of the repo dir' ) do |group|
    options[:group] = group
  end
  opts.on( '-n', '--note NOTE', 'Add a note to a server as you create or launch it') do |note|
    options[:note] = note
  end
  opts.on( '-v', '--version VERSION', 'Update the servers config version on create/start/launch' ) do |version|
    options[:version] = version
  end
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

optparse.parse!

judo = Judo::Base.new(options)
judo.check_version if action != "setup"

begin
  case action
    when "setup" then judo.setup
    when "ips" then do_ips(judo)
    when "volumes" then do_volumes(judo)
    when "list" then do_list(judo, ARGV)
    when "groups" then do_groups(judo)
    when "watch" then find_servers(judo, ARGV)        { |s| s.ssh_command("tail -n 1000 -f /var/log/kuzushi.log") }
    when "info" then find_servers(judo, ARGV)         { |s| do_info(judo, s) }
    when "console" then find_servers(judo, ARGV)      { |s| puts s.console_output }
    when "commit" then find_groups(judo, ARGV)        { |g| g.compile }
    when "ssh" then find_servers(judo, ARGV)          { |s| s.connect_ssh }
    when "start" then find_servers(judo, ARGV)        { |s| s.start(options) }
    when "restart" then find_servers(judo, ARGV)      { |s| s.restart(options) }
    when "stop" then find_servers(judo, ARGV)         { |s| s.stop(options) }
    when "create" then mk_servers(judo, options, ARGV)
    when "launch" then mk_servers(judo, options, ARGV)         { |s| s.start(options) }
    when "snapshots" then do_snapshots(judo, ARGV)
    when "config" then
      puts "Judo DB Version: #{judo.db_version}"
      puts "Judo Keypair:    #{judo.key_name}"
    when "rename" then
      raise JudoError, "usage: judo rename SERVER SERVER" unless ARGV.size == 2
      old,new = ARGV
      server = find_servers(judo, [old]).first
      server.rename(new)
    when "swap" then
      servers = find_servers(judo, ARGV)
      raise JudoError, "usage: judo swapip SERVER SERVER" unless servers.size == 2
      servers[0].swap(servers[1])
    when "erase" then
      raise JudoError, "usage: judo erase SNAPSHOT" unless ARGV.size == 1
      snapshot_name = ARGV.shift
      judo.snapshots.select { |s| s.name == snapshot_name }.each { |s| s.destroy }
    when "snapshot" then
      raise JudoError, "usage: judo snapshot SERVER SNAPSHOT" unless ARGV.size == 2
      server_name = ARGV.shift
      snapshot_name = ARGV.shift
      servers = find_servers(judo, [server_name])
      raise JudoError, "You must specify a valid server to snapshot" if servers.empty?
      raise JudoError, "You can only snapshot one server at a time" if servers.size > 1
      servers[0].snapshot(snapshot_name)
    when "animate" then
      snapshot_name = ARGV.shift
      raise JudoError, "You must specify a snapshot name" unless snapshot_name
      new_server = ARGV.shift
      raise JudoError, "You must specify a new server name" unless new_server
      snapshot = judo.snapshots.detect { |s| s.name == snapshot_name }
      raise JudoError, "No such snapshot #{snapshot_name}" unless snapshot
      snapshot.animate(new_server).start(options)
    when "destroy" then
      raise JudoError, "You must specify what servers to destroy" if ARGV.empty?
      find_either(judo, ARGV) do |i|
        i.destroy
      end
    else
      raise JudoError, "No such action #{action}"
  end
rescue JudoError => e
  puts "Error: #{e.message}"
  exit 1
end
